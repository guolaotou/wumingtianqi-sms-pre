# 技术

## golang多生产者消费者
因为架构中设计多个生产者消费者模式（订单 -> 处理； 短信 -> 处理），因此需要较好的利用golang的生产者消费者技巧
> https://blog.csdn.net/zg_hover/article/details/81048179

## golang的定时器NewTimer、NewTicker使用
因为不同的人定制的发送短信的时间不一样，因此需要每分钟都遍历订单数据库
> https://blog.csdn.net/busai2/article/details/82503699

## 协程间的信道
> https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.2.md

## 思考
1. 如果要控制每秒钟发送的短信数，这个数小于100，那么怎么做会比较好（控制消费者速度）
答：可用开启1000个线程作为消费者，每个线程控制10秒最多只能发送1条短信
那么问题演变成：如何做到控制一个函数每10秒最多只能做1件事；并且能保证假设这件事用了5秒，那么再过5秒就能接收新的任务；
答2：
>事前事后计时，然后sleep剩余的时间；
time.Sleep(5 * time.Second)
	
2. 如果某一时刻订单，消费者会处理不过来，又不能临时增加消费者，如何避免生产者阻塞生产
增加数据缓冲区，这样如果某一个时间生产的数据太多，会临时存放在缓冲区中，等到消费者慢慢消费；
但是需要注意，如果数据实在太多，就需要增加消费者了；